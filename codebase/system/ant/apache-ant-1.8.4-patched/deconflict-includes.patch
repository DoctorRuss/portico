Index: src/main/org/apache/tools/ant/helper/ProjectHelper2.java
===================================================================
--- src/main/org/apache/tools/ant/helper/ProjectHelper2.java	(revision 1361465)
+++ src/main/org/apache/tools/ant/helper/ProjectHelper2.java	(working copy)
@@ -155,6 +155,10 @@
         if (getImportStack().size() > 1) {
             // we are in an imported file.
             context.setIgnoreProjectTag(true);
+            // Tim - Store the prefix used so we can refer to it later in dependency resolution
+            if( getCurrentTargetPrefix() != null ) {
+                project.getDeclaredPrefixes().add( getCurrentTargetPrefix() );
+            }
             Target currentTarget = context.getCurrentTarget();
             Target currentImplicit = context.getImplicitTarget();
             Map    currentTargets = context.getCurrentTargets();
@@ -181,31 +185,55 @@
 
             // resolve extensionOf attributes
             for (String[] extensionInfo : getExtensionStack()) {
-                String tgName = extensionInfo[0];
-                String name = extensionInfo[1];
+                String tgName = extensionInfo[0]; // point we are extending
+                String name = extensionInfo[1];   // name of the target doing the extending
                 OnMissingExtensionPoint missingBehaviour = OnMissingExtensionPoint
                         .valueOf(extensionInfo[2]);
+                // if the file has been included or imported, it may have a prefix we should
+                // consider when trying to resolve the target it is extending
+                String prefix = extensionInfo.length > 3 ? extensionInfo[3] : null;
+                
+                // find the target we're extending
                 Hashtable projectTargets = project.getTargets();
-                if (!projectTargets.containsKey(tgName)) {
+                Target target = null;
+                if( prefix == null ) {
+                    // no prefix - not from an imported/included build file
+                    target = (Target)projectTargets.get(tgName);
+                }
+                else {
+                	// we have a prefix, which means we came from an
+                	// include/import, so we should check with the prefixed
+                	// name first so that we try resolve from the local file
+                	// and then fall back to targets from other files
+                	String sep = getCurrentPrefixSeparator();
+                	target = (Target)projectTargets.get(prefix+sep+tgName);
+                	if( target == null ) {
+                		// we didn't find it under the prefixed name, if
+                		// it's from a different file it might under its
+                		// normal name
+                		target = (Target)projectTargets.get(tgName);
+                	}
+                }
+                
+                // make sure we found a point to extend on
+                if( target == null ) {
                     String message = "can't add target " + name
                         + " to extension-point " + tgName
                         + " because the extension-point is unknown.";
                     if (missingBehaviour == OnMissingExtensionPoint.FAIL) {
                         throw new BuildException(message);
                     } else if (missingBehaviour == OnMissingExtensionPoint.WARN) {
-                        Target target = (Target) projectTargets.get(name);
-                        context.getProject().log(target,
+                        context.getProject().log((Target) projectTargets.get(name),
                                                  "Warning: " + message,
                                                  Project.MSG_WARN);
                     }
                 } else {
-                    Target t = (Target) projectTargets.get(tgName);
-                    if (!(t instanceof ExtensionPoint)) {
+                    if (!(target instanceof ExtensionPoint)) {
                         throw new BuildException("referenced target "
                                                  + tgName
                                                  + " is not an extension-point");
                     }
-                    t.addDependency(name);
+                    target.addDependency(name);
                 }
             }
         }
@@ -1039,16 +1067,22 @@
                     (ProjectHelper) context.getProject().
                     getReference(ProjectHelper.PROJECTHELPER_REFERENCE);
                 for (String tgName : Target.parseDepends(extensionPoint, name, "extensionOf")) {
-                    if (isInIncludeMode()) {
-                        tgName = prefix + sep + tgName;
-                    }
                     if (extensionPointMissing == null) {
                         extensionPointMissing = OnMissingExtensionPoint.FAIL;
                     }
                     // defer extensionpoint resolution until the full
                     // import stack has been processed
-                    helper.getExtensionStack().add(new String[] {
-                            tgName, name, extensionPointMissing.name() });
+                    if(isInIncludeMode()) {
+                        // if in include mode, provide prefix we're including
+                        // by so that we can try and resolve extension point
+                        // from the local file first
+                        helper.getExtensionStack().add(new String[] {
+                            tgName, target.getName(), extensionPointMissing.name(), prefix});
+                    }
+                    else {
+                        helper.getExtensionStack().add(new String[]{
+                            tgName, target.getName(), extensionPointMissing.name()});
+                    }
                 }
             }
         }
Index: src/main/org/apache/tools/ant/Project.java
===================================================================
--- src/main/org/apache/tools/ant/Project.java	(revision 1361465)
+++ src/main/org/apache/tools/ant/Project.java	(working copy)
@@ -146,6 +146,9 @@
     /** Name of the project's default target. */
     private String defaultTarget;
 
+    /** Set of prefixes that have been used by imported or included files */
+    private Set declaredPrefixes = new HashSet();
+
     /** Map from target names to targets (String to Target). */
     private Hashtable targets = new Hashtable();
     /** Set of global filters. */
@@ -780,6 +783,13 @@
     }
 
     /**
+     * Gets a set of all the prefixes used in this project by imported or included files
+     */
+    public Set getDeclaredPrefixes() {
+        return this.declaredPrefixes;
+    }
+
+    /**
      * Add a filter to the set of global filters.
      *
      * @param token The token to filter.
@@ -1894,7 +1904,7 @@
         visiting.push(root);
 
         Target target = (Target) targetTable.get(root);
-
+        
         // Make sure we exist
         if (target == null) {
             StringBuffer sb = new StringBuffer("Target \"");
Index: src/main/org/apache/tools/ant/Main.java
===================================================================
--- src/main/org/apache/tools/ant/Main.java	(revision 1361465)
+++ src/main/org/apache/tools/ant/Main.java	(working copy)
@@ -27,6 +27,7 @@
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Properties;
@@ -796,6 +797,22 @@
                     }
                 }
 
+                // Tim - When including files, target names are automatically prefixed with
+                //       a value as defined in the including build file. This prefix is given
+                //       to all targets defined in the file, including declared dependencies.
+                //       While this works fine for dependencies that reside inside the same
+                //       file (as they all get the same prefix and so are essentially still
+                //       accessible by the same name), if you want to include targets from
+                //       another file, the prefix of the file being included is stuck on the
+                //       front, thus making it appear like the target doesn't exist.
+                //       To solve this, we store any prefixes used when including files in
+                //       a project and then here, should be not be able to locate targets or
+                //       dependencies in a fully complete build, we strip the prefix off to
+                //       see if that was the cause of the problem. If it was, we rewrite the
+                //       name of the target or dependency.
+                resolvePrefixedDependencies( project );
+
+
                 project.executeTargets(targets);
             } finally {
                 // put back the original security manager
@@ -837,6 +854,61 @@
         }
     }
 
+	/**
+	 * Spin through all the targets in this class and check their dependency list. If they
+	 * mention a target that does not exist, try and resolve it using the name without the
+	 * prefix of any imported or included files. When they are loaded, all targets (and deps)
+	 * are given a prefix. If you are referencing a target outside of the local project, it
+	 * will fail because the dependency will get prefixed as well. This just checks for cases
+	 * where that has happened and changes the dependency to point to the correct name when
+	 * it does happen.
+	 *
+	 * @param project The project we are working in
+	 */
+    private void resolvePrefixedDependencies( Project project ) {
+        Hashtable allTargets = project.getTargets();
+        Enumeration targetsEnumeration = allTargets.elements();
+        while( targetsEnumeration.hasMoreElements() )
+        {
+            // for each of the targets in the project, check all their depdendencies to
+            // ensure they can't be found, attempting to find with prefixes removed if not
+            Target target = (Target)targetsEnumeration.nextElement();
+            Enumeration dependencies = target.getDependencies();
+            while( dependencies.hasMoreElements() ) {
+                String dependency = (String)dependencies.nextElement();
+                if( project.getTargets().containsKey(dependency) )
+                    continue;
+                
+                // this target has a dependency that we can't find in the
+                // project, try removing any of the loaded prefixes from it
+                // name to see if we can, and should we be able to, replace
+                // the dependency
+                Set prefixes = project.getDeclaredPrefixes();
+                Iterator iterator = prefixes.iterator();
+                Target resolved = null;
+                while( iterator.hasNext() ) {
+                    String prefix = (String)iterator.next();
+                    // check the start of the target name, don't want to replace middle pieces
+                    // of the target name and find a match! (wouldn't be a prefix then)
+                    if( dependency.startsWith(prefix) == false )
+                        continue;
+
+                    String alternative = dependency.replace( prefix+".", "" );
+                    if( project.getTargets().containsKey(alternative) ) {
+                        // Found it!
+                        resolved = (Target)allTargets.get( alternative );
+                        break;
+                    }
+                }
+                
+                // replace the target with the proper name if required
+                if( resolved != null ) {
+                    target.replaceDependency( dependency, resolved.getName() );
+                }
+            }
+        }
+    }
+
     private void setProperties(final Project project) {
         
         project.init();
Index: src/main/org/apache/tools/ant/Target.java
===================================================================
--- src/main/org/apache/tools/ant/Target.java	(revision 1361465)
+++ src/main/org/apache/tools/ant/Target.java	(working copy)
@@ -253,6 +253,18 @@
     }
 
     /**
+     * Replaces the identified existing target dependency with the provided new one.
+     * If the given dependency does not exist in the list of dependencies that we have,
+     * no replace shall take place.
+     */
+    public void replaceDependency( String previousDependency, String newDependency ) {
+        int index = dependencies.indexOf( previousDependency );
+        if( index >= 0 ) {
+            dependencies.set( index, newDependency );
+        }
+    }
+
+    /**
      * Does this target depend on the named target?
      * @param other the other named target.
      * @return true if the target does depend on the named target
Index: patch.xml
===================================================================
--- patch.xml	(revision 1361465)
+++ patch.xml	(working copy)
@@ -1,61 +1,264 @@
-<?xml version="1.0"?>
-
-<!--
-   Licensed to the Apache Software Foundation (ASF) under one or more
-   contributor license agreements.  See the NOTICE file distributed with
-   this work for additional information regarding copyright ownership.
-   The ASF licenses this file to You under the Apache License, Version 2.0
-   (the "License"); you may not use this file except in compliance with
-   the License.  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
--->
-<!--
-  =======================================================================
-   Use Apache Ant to generate a patch file for Apache Ant.
-  =======================================================================
--->
-<project name="create-patch" default="patchpackage" basedir=".">
-    <property environment="env"/>
-    <property name="patch.package" value="patch.tar.gz"/>
-    <property name="patch.file" value="patch.txt"/>
-
-    <condition property="svn.found">
-        <or>
-            <available file="svn" filepath="${env.PATH}"/>
-            <available file="svn.exe" filepath="${env.PATH}"/>
-            <available file="svn.exe" filepath="${env.Path}"/>
-        </or>
-    </condition>
-
-    <target name="createpatch">
-        <fail unless="svn.found"
-              message="You need a version of svn to create the patch"/>
-        <exec executable="svn" output="${patch.file}">
-            <arg value="diff"/>
-        </exec>
-    </target>
-
-    <target name="newfiles" depends="createpatch">
-        <delete file="${patch.package}"/>
-        <exec executable="svn" output="${patch.file}.tmp">
-            <arg value="status"/>
-        </exec>
-        <replace file="${patch.file}.tmp" token="?      " value=""/>
-    </target>
-
-    <target name="patchpackage" depends="newfiles">
-        <tar basedir="${basedir}"
-            tarfile="${patch.package}"
-            compression="gzip"
-            includesfile="${patch.file}.tmp"
-            excludes="${patch.file}.tmp"/>
-        <delete file="${patch.file}.tmp"/>
-    </target>
-</project>
+Index: src/main/org/apache/tools/ant/helper/ProjectHelper2.java
+===================================================================
+--- src/main/org/apache/tools/ant/helper/ProjectHelper2.java	(revision 1361465)
++++ src/main/org/apache/tools/ant/helper/ProjectHelper2.java	(working copy)
+@@ -155,6 +155,10 @@
+         if (getImportStack().size() > 1) {
+             // we are in an imported file.
+             context.setIgnoreProjectTag(true);
++            // Tim - Store the prefix used so we can refer to it later in dependency resolution
++            if( getCurrentTargetPrefix() != null ) {
++                project.getDeclaredPrefixes().add( getCurrentTargetPrefix() );
++            }
+             Target currentTarget = context.getCurrentTarget();
+             Target currentImplicit = context.getImplicitTarget();
+             Map    currentTargets = context.getCurrentTargets();
+@@ -181,31 +185,55 @@
+ 
+             // resolve extensionOf attributes
+             for (String[] extensionInfo : getExtensionStack()) {
+-                String tgName = extensionInfo[0];
+-                String name = extensionInfo[1];
++                String tgName = extensionInfo[0]; // point we are extending
++                String name = extensionInfo[1];   // name of the target doing the extending
+                 OnMissingExtensionPoint missingBehaviour = OnMissingExtensionPoint
+                         .valueOf(extensionInfo[2]);
++                // if the file has been included or imported, it may have a prefix we should
++                // consider when trying to resolve the target it is extending
++                String prefix = extensionInfo.length > 3 ? extensionInfo[3] : null;
++                
++                // find the target we're extending
+                 Hashtable projectTargets = project.getTargets();
+-                if (!projectTargets.containsKey(tgName)) {
++                Target target = null;
++                if( prefix == null ) {
++                    // no prefix - not from an imported/included build file
++                    target = (Target)projectTargets.get(tgName);
++                }
++                else {
++                	// we have a prefix, which means we came from an
++                	// include/import, so we should check with the prefixed
++                	// name first so that we try resolve from the local file
++                	// and then fall back to targets from other files
++                	String sep = getCurrentPrefixSeparator();
++                	target = (Target)projectTargets.get(prefix+sep+tgName);
++                	if( target == null ) {
++                		// we didn't find it under the prefixed name, if
++                		// it's from a different file it might under its
++                		// normal name
++                		target = (Target)projectTargets.get(tgName);
++                	}
++                }
++                
++                // make sure we found a point to extend on
++                if( target == null ) {
+                     String message = "can't add target " + name
+                         + " to extension-point " + tgName
+                         + " because the extension-point is unknown.";
+                     if (missingBehaviour == OnMissingExtensionPoint.FAIL) {
+                         throw new BuildException(message);
+                     } else if (missingBehaviour == OnMissingExtensionPoint.WARN) {
+-                        Target target = (Target) projectTargets.get(name);
+-                        context.getProject().log(target,
++                        context.getProject().log((Target) projectTargets.get(name),
+                                                  "Warning: " + message,
+                                                  Project.MSG_WARN);
+                     }
+                 } else {
+-                    Target t = (Target) projectTargets.get(tgName);
+-                    if (!(t instanceof ExtensionPoint)) {
++                    if (!(target instanceof ExtensionPoint)) {
+                         throw new BuildException("referenced target "
+                                                  + tgName
+                                                  + " is not an extension-point");
+                     }
+-                    t.addDependency(name);
++                    target.addDependency(name);
+                 }
+             }
+         }
+@@ -1039,16 +1067,22 @@
+                     (ProjectHelper) context.getProject().
+                     getReference(ProjectHelper.PROJECTHELPER_REFERENCE);
+                 for (String tgName : Target.parseDepends(extensionPoint, name, "extensionOf")) {
+-                    if (isInIncludeMode()) {
+-                        tgName = prefix + sep + tgName;
+-                    }
+                     if (extensionPointMissing == null) {
+                         extensionPointMissing = OnMissingExtensionPoint.FAIL;
+                     }
+                     // defer extensionpoint resolution until the full
+                     // import stack has been processed
+-                    helper.getExtensionStack().add(new String[] {
+-                            tgName, name, extensionPointMissing.name() });
++                    if(isInIncludeMode()) {
++                        // if in include mode, provide prefix we're including
++                        // by so that we can try and resolve extension point
++                        // from the local file first
++                        helper.getExtensionStack().add(new String[] {
++                            tgName, target.getName(), extensionPointMissing.name(), prefix});
++                    }
++                    else {
++                        helper.getExtensionStack().add(new String[]{
++                            tgName, target.getName(), extensionPointMissing.name()});
++                    }
+                 }
+             }
+         }
+Index: src/main/org/apache/tools/ant/Project.java
+===================================================================
+--- src/main/org/apache/tools/ant/Project.java	(revision 1361465)
++++ src/main/org/apache/tools/ant/Project.java	(working copy)
+@@ -146,6 +146,9 @@
+     /** Name of the project's default target. */
+     private String defaultTarget;
+ 
++    /** Set of prefixes that have been used by imported or included files */
++    private Set declaredPrefixes = new HashSet();
++
+     /** Map from target names to targets (String to Target). */
+     private Hashtable targets = new Hashtable();
+     /** Set of global filters. */
+@@ -780,6 +783,13 @@
+     }
+ 
+     /**
++     * Gets a set of all the prefixes used in this project by imported or included files
++     */
++    public Set getDeclaredPrefixes() {
++        return this.declaredPrefixes;
++    }
++
++    /**
+      * Add a filter to the set of global filters.
+      *
+      * @param token The token to filter.
+@@ -1894,7 +1904,7 @@
+         visiting.push(root);
+ 
+         Target target = (Target) targetTable.get(root);
+-
++        
+         // Make sure we exist
+         if (target == null) {
+             StringBuffer sb = new StringBuffer("Target \"");
+Index: src/main/org/apache/tools/ant/Main.java
+===================================================================
+--- src/main/org/apache/tools/ant/Main.java	(revision 1361465)
++++ src/main/org/apache/tools/ant/Main.java	(working copy)
+@@ -27,6 +27,7 @@
+ import java.util.Enumeration;
+ import java.util.HashMap;
+ import java.util.HashSet;
++import java.util.Hashtable;
+ import java.util.Iterator;
+ import java.util.Map;
+ import java.util.Properties;
+@@ -796,6 +797,22 @@
+                     }
+                 }
+ 
++                // Tim - When including files, target names are automatically prefixed with
++                //       a value as defined in the including build file. This prefix is given
++                //       to all targets defined in the file, including declared dependencies.
++                //       While this works fine for dependencies that reside inside the same
++                //       file (as they all get the same prefix and so are essentially still
++                //       accessible by the same name), if you want to include targets from
++                //       another file, the prefix of the file being included is stuck on the
++                //       front, thus making it appear like the target doesn't exist.
++                //       To solve this, we store any prefixes used when including files in
++                //       a project and then here, should be not be able to locate targets or
++                //       dependencies in a fully complete build, we strip the prefix off to
++                //       see if that was the cause of the problem. If it was, we rewrite the
++                //       name of the target or dependency.
++                resolvePrefixedDependencies( project );
++
++
+                 project.executeTargets(targets);
+             } finally {
+                 // put back the original security manager
+@@ -837,6 +854,61 @@
+         }
+     }
+ 
++	/**
++	 * Spin through all the targets in this class and check their dependency list. If they
++	 * mention a target that does not exist, try and resolve it using the name without the
++	 * prefix of any imported or included files. When they are loaded, all targets (and deps)
++	 * are given a prefix. If you are referencing a target outside of the local project, it
++	 * will fail because the dependency will get prefixed as well. This just checks for cases
++	 * where that has happened and changes the dependency to point to the correct name when
++	 * it does happen.
++	 *
++	 * @param project The project we are working in
++	 */
++    private void resolvePrefixedDependencies( Project project ) {
++        Hashtable allTargets = project.getTargets();
++        Enumeration targetsEnumeration = allTargets.elements();
++        while( targetsEnumeration.hasMoreElements() )
++        {
++            // for each of the targets in the project, check all their depdendencies to
++            // ensure they can't be found, attempting to find with prefixes removed if not
++            Target target = (Target)targetsEnumeration.nextElement();
++            Enumeration dependencies = target.getDependencies();
++            while( dependencies.hasMoreElements() ) {
++                String dependency = (String)dependencies.nextElement();
++                if( project.getTargets().containsKey(dependency) )
++                    continue;
++                
++                // this target has a dependency that we can't find in the
++                // project, try removing any of the loaded prefixes from it
++                // name to see if we can, and should we be able to, replace
++                // the dependency
++                Set prefixes = project.getDeclaredPrefixes();
++                Iterator iterator = prefixes.iterator();
++                Target resolved = null;
++                while( iterator.hasNext() ) {
++                    String prefix = (String)iterator.next();
++                    // check the start of the target name, don't want to replace middle pieces
++                    // of the target name and find a match! (wouldn't be a prefix then)
++                    if( dependency.startsWith(prefix) == false )
++                        continue;
++
++                    String alternative = dependency.replace( prefix+".", "" );
++                    if( project.getTargets().containsKey(alternative) ) {
++                        // Found it!
++                        resolved = (Target)allTargets.get( alternative );
++                        break;
++                    }
++                }
++                
++                // replace the target with the proper name if required
++                if( resolved != null ) {
++                    target.replaceDependency( dependency, resolved.getName() );
++                }
++            }
++        }
++    }
++
+     private void setProperties(final Project project) {
+         
+         project.init();
+Index: src/main/org/apache/tools/ant/Target.java
+===================================================================
+--- src/main/org/apache/tools/ant/Target.java	(revision 1361465)
++++ src/main/org/apache/tools/ant/Target.java	(working copy)
+@@ -253,6 +253,18 @@
+     }
+ 
+     /**
++     * Replaces the identified existing target dependency with the provided new one.
++     * If the given dependency does not exist in the list of dependencies that we have,
++     * no replace shall take place.
++     */
++    public void replaceDependency( String previousDependency, String newDependency ) {
++        int index = dependencies.indexOf( previousDependency );
++        if( index >= 0 ) {
++            dependencies.set( index, newDependency );
++        }
++    }
++
++    /**
+      * Does this target depend on the named target?
+      * @param other the other named target.
+      * @return true if the target does depend on the named target
